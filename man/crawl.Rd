% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crawl.R
\name{crawl}
\alias{crawl}
\title{Crawl BLAST databases with a set of query files}
\usage{
crawl(
  blast_executable,
  query_paths,
  db_paths,
  blast_executable_directory = NULL,
  outfmt_specifiers =
    "qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore",
  extra_blast_arguments = NULL,
  use_long_names_in_parsed_result = FALSE,
  job_failed_callback = function(query_path, db_path, exit_status) {
 },
  parse_failed_callback = function(query_path, db_path, error_condition) {
 }
)
}
\arguments{
\item{blast_executable}{\code{[character(1)]}\cr
Name of the BLAST executable to run (e.g. \code{"blastn"}, \code{"blastp"}).
If \code{blast_executable_directory} is provided the executable will be
looked up in that directory; otherwise the PATH is searched.}

\item{query_paths}{\code{[character]}\cr
One or more paths to query files.}

\item{db_paths}{\code{[character]}\cr
One or more BLAST DB base paths.}

\item{blast_executable_directory}{\code{[character(1) | NULL]}\cr
Optional directory in which to look for \code{blast_executable}. If
non-\code{NULL} the executable is resolved via \code{file.path(directory,
blast_executable)}. May be \code{NULL}.}

\item{outfmt_specifiers}{\code{[character(1)]}\cr
Space-separated string of BLAST short-format specifiers to
request (the part after the leading \code{6} in \code{-outfmt}). Use
\code{NULL}, empty string, or the BLAST keyword \code{"std"} to select the
package default set. The default matches BLAST's common short-format
columns: qaccver saccver pident length mismatch gapopen qstart
qend sstart send evalue bitscore.}

\item{extra_blast_arguments}{\code{[character | NULL]}\cr
Additional command-line arguments passed through to the BLAST command.
This must not include an \code{-outfmt} argument. May be \code{NULL}.}

\item{use_long_names_in_parsed_result}{\code{[logical(1)]}\cr
If \code{TRUE} the resulting tibble will use long, descriptive column
names mapped from the short-format specifiers. If \code{FALSE} short
specifier names are used as column names.}

\item{job_failed_callback}{\code{[function]}\cr
Function called when a BLAST process exits with a non-zero status (or a
NA status). Called as \code{job_failed_callback(query_path, db_path,
exit_status)}. The default is a no-op function.}

\item{parse_failed_callback}{\code{[function]}\cr
Function called when parsing the BLAST stdout fails. Called as
\code{parse_failed_callback(query_path, db_path, error_condition)}. The
default is a no-op function.}
}
\value{
A tibble combining the parsed BLAST hits from all successful
  query/DB runs. Column names correspond to the selected format specifiers
  (short or long names, depending on \code{use_long_names_in_parsed_result})
  and column types are those defined by the package format-specifier
  mapping. The returned tibble may have zero rows (e.g., if all jobs fail or
  produce no hits).
}
\description{
Run a BLAST executable for every combination of query file and BLAST DB
base path and return the combined parsed results as a tibble. This function
constructs the appropriate command-line arguments (including a -outfmt 6
short-format specifier), invokes the BLAST executable, parses the TSV BLAST output and binds all results together.
}
\details{
The function validates inputs and supports user callbacks for two
failure modes: when a BLAST job exits with non-zero status, and when parse
of the BLAST stdout fails. Parallel execution across query/DB pairs is
supported via the future package, so be sure to set a plan before running this function like \code{future::plan(future::multisession, workers = 2)}.
}
\examples{
\dontrun{
# Basic usage (assumes blastn is on PATH and DBs exist)
results <- crawl(
  blast_executable = "blastn",
  query_paths = c("queries/a.fasta", "queries/b.fasta"),
  db_paths = c("/data/db/nt", "/data/db/custom_db")
)

# Provide callbacks to log failures
crawl(
  blast_executable = "blastn",
  query_paths = "queries/a.fasta",
  db_paths = "dbs/nt",
  job_failed_callback = function(query_path, db_path, exit_status) {
    message("BLAST job failed for ", query_path, " vs ", db_path, ": ", exit_status)
  },
  parse_failed_callback = function(query_path, db_path, error_condition) {
    message(
      "Failed to parse BLAST output for ",
      query_path,
      " vs ",
      db_path,
      ": ",
      error_condition$message
    )
  }
)
}

}
